/**
 * 左值引用，右值引用
 * https://www.cnblogs.com/likaiming/p/9045642.html
 */

#include <iostream>

using namespace std;

int main() {
    /* 左值和右值的区分标准在于能否获取地址。
     * 最早的c++中，左值的定义表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。
     * 右值表示无法获取地址的对象，有常量值、函数返回值、Lambda表达式等。无法获取地址，但不表示其不可改变，
     * 当定义了右值的右值引用时就可以更改右值。
     * */

    // int &i = 10; // 左值引用不能赋值一个右值
    const int &i = 10; // 如果左值引用加上一个const，则可以赋值一个右值

    // 传统的c++引用被称为左值引用
    int j = 10;
    int & jj = j;

    // C++ Primer Plus 第6版18.1.9中说到，c++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，
    // 也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置。语法如下：
    int && jjj = 10;

    // 能将右值引用赋值给左值引用，该左值引用绑定到右值引用指向的对象
    int &ii = jjj;

    // 根据右值引用的语法规则可知，不能将右值引用绑定到一个左值上，c++11引入右值引用，并且提供了move函数，用来获得绑定到左值上的右值引用，
    // 此函数定义在头文件utility中。
    // 调用move之后，必须保证除了对ii复制或销毁它外，我们将不再使用它，在调用move之后，我们不能对移动源后对象做任何假设。
    int && iii = move(ii);
    iii = 1;
    cout << "ii: " << ii << endl;
}
